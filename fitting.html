<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Performing Fits, Analyzing Outputs &mdash; Non-Linear Least-Squares Minimization and Curve-Fitting for Python</title>
    
    <link rel="stylesheet" href="_static/lmfitdoc.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '0.9.4',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="top" title="Non-Linear Least-Squares Minimization and Curve-Fitting for Python" href="index.html" />
    <link rel="next" title="Modeling Data and Curve Fitting" href="model.html" />
    <link rel="prev" title="Parameter and Parameters" href="parameters.html" />
  <script type="text/x-mathjax-config">
     MathJax.Hub.Config({
        "TeX": {Macros: {AA : "{\\unicode{x212B}}"}},
        "HTML-CSS": {scale: 90}
  });</script>

  </head>
  <body role="document">
<div>
<table border=0>
  <tr><td></td><td width=85% padding=5 align=left>
       <a href="index.html" style="color: #157"> <font size=+3>LMFIT</font></a>
     </td>
     <td width=7% align=left>
         <a href="contents.html" style="color: #882222">
         <font size+=1>Contents</font></a> </td>
     <td width=7% align=left>
          <a href="installation.html" style="color: #882222">
          <font size+=1>Download</font></a></td>
     <td></td>
  </tr>
  <tr><td></td><td width=75% padding=5 align=left>
        <a href="index.html" style="color: #157"> <font size=+2>
	Non-Linear Least-Squares Minimization and Curve-Fitting for Python</font></a>
     </td>
     <td width=7% align=left>
         <a href="faq.html" style="color: #882222">
         <font size+=1>FAQ</font></a> </td>
     <td width=7% align=left>
        <a href="https://github.com/lmfit/lmfit-py/" style="color: #882222">
         <font size+=1>Develop</font></a></td>
     <td></td>
  </tr>
</table>
</div>

    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="model.html" title="Modeling Data and Curve Fitting"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="parameters.html" title="Parameter and Parameters"
             accesskey="P">previous</a> |</li>
   <li>[<a href="intro.html">intro</a>|</li>
   <li><a href="parameters.html">parameters</a>|</li>
   <li><a href="#"> minimize</a>|</li>
   <li><a href="model.html"> model</a>|</li>
   <li><a href="builtin_models.html"> builtin models</a>|</li>
   <li><a href="confidence.html">confidence intervals</a>|</li>
   <li><a href="bounds.html">bounds</a>|</li>
   <li><a href="constraints.html">constraints</a>]</li>
 
      </ul>
    </div>

      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Performing Fits, Analyzing Outputs</a><ul>
<li><a class="reference internal" href="#the-minimize-function">The <code class="docutils literal"><span class="pre">minimize()</span></code> function</a></li>
<li><a class="reference internal" href="#writing-a-fitting-function">Writing a Fitting Function</a></li>
<li><a class="reference internal" href="#choosing-different-fitting-methods">Choosing Different Fitting Methods</a></li>
<li><a class="reference internal" href="#minimizerresult-the-optimization-result"><code class="docutils literal"><span class="pre">MinimizerResult</span></code> &#8211; the optimization result</a><ul>
<li><a class="reference internal" href="#goodness-of-fit-statistics">Goodness-of-Fit Statistics</a></li>
<li><a class="reference internal" href="#akaike-and-bayesian-information-criteria">Akaike and Bayesian Information Criteria</a></li>
</ul>
</li>
<li><a class="reference internal" href="#using-a-iteration-callback-function">Using a Iteration Callback Function</a></li>
<li><a class="reference internal" href="#using-the-minimizer-class">Using the <code class="docutils literal"><span class="pre">Minimizer</span></code> class</a></li>
<li><a class="reference internal" href="#emcee-calculating-the-posterior-probability-distribution-of-parameters"><code class="docutils literal"><span class="pre">emcee()</span></code> - calculating the posterior probability distribution of parameters</a></li>
<li><a class="reference internal" href="#getting-and-printing-fit-reports">Getting and Printing Fit Reports</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="parameters.html"
                        title="previous chapter"><code class="docutils literal"><span class="pre">Parameter</span></code>  and <code class="docutils literal"><span class="pre">Parameters</span></code></a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="model.html"
                        title="next chapter">Modeling Data and Curve Fitting</a></p>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/fitting.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <span class="target" id="module-lmfit.minimizer"><span id="minimize-chapter"></span></span><div class="section" id="performing-fits-analyzing-outputs">
<h1>Performing Fits, Analyzing Outputs<a class="headerlink" href="#performing-fits-analyzing-outputs" title="Permalink to this headline">¶</a></h1>
<p>As shown in the previous chapter, a simple fit can be performed with the
<a class="reference internal" href="#lmfit.minimizer.minimize" title="lmfit.minimizer.minimize"><code class="xref py py-func docutils literal"><span class="pre">minimize()</span></code></a> function.  For more sophisticated modeling, the
<a class="reference internal" href="#lmfit.minimizer.Minimizer" title="lmfit.minimizer.Minimizer"><code class="xref py py-class docutils literal"><span class="pre">Minimizer</span></code></a> class can be used to gain a bit more control, especially
when using complicated constraints or comparing results from related fits.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">Upgrading scripts from version 0.8.3 to 0.9.0?  See  <a class="reference internal" href="whatsnew.html#whatsnew-090-label"><span>Version 0.9.0 Release Notes</span></a></p>
</div>
<div class="section" id="the-minimize-function">
<h2>The <a class="reference internal" href="#lmfit.minimizer.minimize" title="lmfit.minimizer.minimize"><code class="xref py py-func docutils literal"><span class="pre">minimize()</span></code></a> function<a class="headerlink" href="#the-minimize-function" title="Permalink to this headline">¶</a></h2>
<p>The <a class="reference internal" href="#lmfit.minimizer.minimize" title="lmfit.minimizer.minimize"><code class="xref py py-func docutils literal"><span class="pre">minimize()</span></code></a> function is a wrapper around <a class="reference internal" href="#lmfit.minimizer.Minimizer" title="lmfit.minimizer.Minimizer"><code class="xref py py-class docutils literal"><span class="pre">Minimizer</span></code></a> for
running an optimization problem.  It takes an objective function (the
function that calculates the array to be minimized), a <code class="xref py py-class docutils literal"><span class="pre">Parameters</span></code>
object, and several optional arguments.  See <a class="reference internal" href="#fit-func-label"><span>Writing a Fitting Function</span></a> for
details on writing the objective.</p>
<dl class="function">
<dt id="lmfit.minimizer.minimize">
<code class="descname">minimize</code><span class="sig-paren">(</span><em>function</em>, <em>params</em><span class="optional">[</span>, <em>args=None</em><span class="optional">[</span>, <em>kws=None</em><span class="optional">[</span>, <em>method='leastsq'</em><span class="optional">[</span>, <em>scale_covar=True</em><span class="optional">[</span>, <em>iter_cb=None</em><span class="optional">[</span>, <em>**fit_kws</em><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#lmfit.minimizer.minimize" title="Permalink to this definition">¶</a></dt>
<dd><p>find values for the <code class="docutils literal"><span class="pre">params</span></code> so that the sum-of-squares of the array returned
from <code class="docutils literal"><span class="pre">function</span></code> is minimized.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>function</strong> (<em>callable.</em>) &#8211; function to return fit residual.  See <a class="reference internal" href="#fit-func-label"><span>Writing a Fitting Function</span></a> for details.</li>
<li><strong>params</strong> (<code class="xref py py-class docutils literal"><span class="pre">Parameters</span></code>.) &#8211; a <code class="xref py py-class docutils literal"><span class="pre">Parameters</span></code> dictionary.  Keywords must be strings
that match <code class="docutils literal"><span class="pre">[a-z_][a-z0-9_]*</span></code> and cannot be a python
reserved word.  Each value must be <code class="xref py py-class docutils literal"><span class="pre">Parameter</span></code>.</li>
<li><strong>args</strong> (<em>tuple</em>) &#8211; arguments tuple to pass to the residual function as  positional arguments.</li>
<li><strong>kws</strong> (<em>dict</em>) &#8211; dictionary to pass to the residual function as keyword arguments.</li>
<li><strong>method</strong> (string (default <code class="docutils literal"><span class="pre">leastsq</span></code>)) &#8211; name of fitting method to use. See  <a class="reference internal" href="#fit-methods-label"><span>Choosing Different Fitting Methods</span></a> for details</li>
<li><strong>scale_covar</strong> (bool (default <code class="docutils literal"><span class="pre">True</span></code>)) &#8211; whether to automatically scale covariance matrix (<code class="docutils literal"><span class="pre">leastsq</span></code> only)</li>
<li><strong>iter_cb</strong> (callable or <code class="docutils literal"><span class="pre">None</span></code>) &#8211; function to be called at each fit iteration. See <a class="reference internal" href="#fit-itercb-label"><span>Using a Iteration Callback Function</span></a> for details.</li>
<li><strong>fit_kws</strong> (<em>dict</em>) &#8211; dictionary to pass to <a class="reference external" href="http://docs.scipy.org/doc/scipy/reference/generated/optimize.leastsq.html">optimize.leastsq</a> or <a class="reference external" href="http://docs.scipy.org/doc/scipy/reference/generated/optimize.minimize.html">optimize.minimize</a>.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#lmfit.minimizer.MinimizerResult" title="lmfit.minimizer.MinimizerResult"><code class="xref py py-class docutils literal"><span class="pre">MinimizerResult</span></code></a> instance, which will contain the
optimized parameter, and several goodness-of-fit statistics.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<div class="versionchanged">
<p><span class="versionmodified">Changed in version 0.9.0: </span>return value changed to <a class="reference internal" href="#lmfit.minimizer.MinimizerResult" title="lmfit.minimizer.MinimizerResult"><code class="xref py py-class docutils literal"><span class="pre">MinimizerResult</span></code></a></p>
<p>On output, the params will be unchanged.  The best-fit values, and where
appropriate, estimated uncertainties and correlations, will all be
contained in the returned <a class="reference internal" href="#lmfit.minimizer.MinimizerResult" title="lmfit.minimizer.MinimizerResult"><code class="xref py py-class docutils literal"><span class="pre">MinimizerResult</span></code></a>.  See
<a class="reference internal" href="#fit-results-label"><span>MinimizerResult &#8211; the optimization result</span></a> for further details.</p>
<p>For clarity, it should be emphasized that this function is simply a
wrapper around <a class="reference internal" href="#lmfit.minimizer.Minimizer" title="lmfit.minimizer.Minimizer"><code class="xref py py-class docutils literal"><span class="pre">Minimizer</span></code></a> that runs a single fit, implemented as:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">fitter</span> <span class="o">=</span> <span class="n">Minimizer</span><span class="p">(</span><span class="n">fcn</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="n">fcn_args</span><span class="o">=</span><span class="n">args</span><span class="p">,</span> <span class="n">fcn_kws</span><span class="o">=</span><span class="n">kws</span><span class="p">,</span>
                   <span class="n">iter_cb</span><span class="o">=</span><span class="n">iter_cb</span><span class="p">,</span> <span class="n">scale_covar</span><span class="o">=</span><span class="n">scale_covar</span><span class="p">,</span> <span class="o">**</span><span class="n">fit_kws</span><span class="p">)</span>
<span class="k">return</span> <span class="n">fitter</span><span class="o">.</span><span class="n">minimize</span><span class="p">(</span><span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="writing-a-fitting-function">
<span id="fit-func-label"></span><h2>Writing a Fitting Function<a class="headerlink" href="#writing-a-fitting-function" title="Permalink to this headline">¶</a></h2>
<p>An important component of a fit is writing a function to be minimized &#8211;
the <em>objective function</em>.  Since this function will be called by other
routines, there are fairly stringent requirements for its call signature
and return value.  In principle, your function can be any python callable,
but it must look like this:</p>
<dl class="function">
<dt>
<code class="descname">func(params, *args, **kws):</code></dt>
<dd><p>calculate objective residual to be minimized from parameters.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>params</strong> (<code class="xref py py-class docutils literal"><span class="pre">Parameters</span></code>.) &#8211; parameters.</li>
<li><strong>args</strong> &#8211; positional arguments.  Must match <code class="docutils literal"><span class="pre">args</span></code> argument to <a class="reference internal" href="#lmfit.minimizer.minimize" title="lmfit.minimizer.minimize"><code class="xref py py-func docutils literal"><span class="pre">minimize()</span></code></a></li>
<li><strong>kws</strong> &#8211; keyword arguments.  Must match <code class="docutils literal"><span class="pre">kws</span></code> argument to <a class="reference internal" href="#lmfit.minimizer.minimize" title="lmfit.minimizer.minimize"><code class="xref py py-func docutils literal"><span class="pre">minimize()</span></code></a></li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">residual array (generally data-model) to be minimized in the least-squares sense.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">numpy array.  The length of this array cannot change between calls.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>A common use for the positional and keyword arguments would be to pass in other
data needed to calculate the residual, including such things as the data array,
dependent variable, uncertainties in the data, and other data structures for the
model calculation.</p>
<p>The objective function should return the value to be minimized.  For the
Levenberg-Marquardt algorithm from <a class="reference internal" href="#lmfit.minimizer.leastsq" title="lmfit.minimizer.leastsq"><code class="xref py py-meth docutils literal"><span class="pre">leastsq()</span></code></a>, this returned value <strong>must</strong> be an
array, with a length greater than or equal to the number of fitting variables in the
model.  For the other methods, the return value can either be a scalar or an array.  If an
array is returned, the sum of squares of the array will be sent to the underlying fitting
method, effectively doing a least-squares optimization of the return values.</p>
<p>Since the function will be passed in a dictionary of <code class="xref py py-class docutils literal"><span class="pre">Parameters</span></code>, it is advisable
to unpack these to get numerical values at the top of the function.  A
simple way to do this is with <code class="xref py py-meth docutils literal"><span class="pre">Parameters.valuesdict()</span></code>, as with:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">residual</span><span class="p">(</span><span class="n">pars</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">eps</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="c1"># unpack parameters:</span>
    <span class="c1">#  extract .value attribute for each parameter</span>
    <span class="n">parvals</span> <span class="o">=</span> <span class="n">pars</span><span class="o">.</span><span class="n">valuesdict</span><span class="p">()</span>
    <span class="n">period</span> <span class="o">=</span> <span class="n">parvals</span><span class="p">[</span><span class="s1">&#39;period&#39;</span><span class="p">]</span>
    <span class="n">shift</span> <span class="o">=</span> <span class="n">parvals</span><span class="p">[</span><span class="s1">&#39;shift&#39;</span><span class="p">]</span>
    <span class="n">decay</span> <span class="o">=</span> <span class="n">parvals</span><span class="p">[</span><span class="s1">&#39;decay&#39;</span><span class="p">]</span>

    <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">shift</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">pi</span><span class="o">/</span><span class="mi">2</span><span class="p">:</span>
        <span class="n">shift</span> <span class="o">=</span> <span class="n">shift</span> <span class="o">-</span> <span class="n">sign</span><span class="p">(</span><span class="n">shift</span><span class="p">)</span><span class="o">*</span><span class="n">pi</span>

    <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">period</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mf">1.e-10</span><span class="p">:</span>
        <span class="n">period</span> <span class="o">=</span> <span class="n">sign</span><span class="p">(</span><span class="n">period</span><span class="p">)</span><span class="o">*</span><span class="mf">1.e-10</span>

    <span class="n">model</span> <span class="o">=</span> <span class="n">parvals</span><span class="p">[</span><span class="s1">&#39;amp&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="n">sin</span><span class="p">(</span><span class="n">shift</span> <span class="o">+</span> <span class="n">x</span><span class="o">/</span><span class="n">period</span><span class="p">)</span> <span class="o">*</span> <span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">x</span><span class="o">*</span><span class="n">x</span><span class="o">*</span><span class="n">decay</span><span class="o">*</span><span class="n">decay</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">data</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">model</span>
    <span class="k">if</span> <span class="n">eps</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">model</span> <span class="o">-</span> <span class="n">data</span><span class="p">)</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">model</span> <span class="o">-</span> <span class="n">data</span><span class="p">)</span><span class="o">/</span><span class="n">eps</span>
</pre></div>
</div>
<p>In this example, <code class="docutils literal"><span class="pre">x</span></code> is a positional (required) argument, while the
<code class="docutils literal"><span class="pre">data</span></code> array is actually optional (so that the function returns the model
calculation if the data is neglected).  Also note that the model
calculation will divide <code class="docutils literal"><span class="pre">x</span></code> by the value of the &#8216;period&#8217; Parameter.  It
might be wise to ensure this parameter cannot be 0.  It would be possible
to use the bounds on the <code class="xref py py-class docutils literal"><span class="pre">Parameter</span></code> to do this:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">params</span><span class="p">[</span><span class="s1">&#39;period&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">Parameter</span><span class="p">(</span><span class="n">value</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="nb">min</span><span class="o">=</span><span class="mf">1.e-10</span><span class="p">)</span>
</pre></div>
</div>
<p>but putting this directly in the function with:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">period</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mf">1.e-10</span><span class="p">:</span>
    <span class="n">period</span> <span class="o">=</span> <span class="n">sign</span><span class="p">(</span><span class="n">period</span><span class="p">)</span><span class="o">*</span><span class="mf">1.e-10</span>
</pre></div>
</div>
<p>is also a reasonable approach.   Similarly, one could place bounds on the
<code class="docutils literal"><span class="pre">decay</span></code> parameter to take values only between <code class="docutils literal"><span class="pre">-pi/2</span></code> and <code class="docutils literal"><span class="pre">pi/2</span></code>.</p>
</div>
<div class="section" id="choosing-different-fitting-methods">
<span id="fit-methods-label"></span><h2>Choosing Different Fitting Methods<a class="headerlink" href="#choosing-different-fitting-methods" title="Permalink to this headline">¶</a></h2>
<p>By default, the <a class="reference external" href="http://en.wikipedia.org/wiki/Levenberg-Marquardt_algorithm">Levenberg-Marquardt</a> algorithm is
used for fitting.  While often criticized, including the fact it finds a
<em>local</em> minima, this approach has some distinct advantages.  These include
being fast, and well-behaved for most curve-fitting needs, and making it
easy to estimate uncertainties for and correlations between pairs of fit
variables, as discussed in <a class="reference internal" href="#fit-results-label"><span>MinimizerResult &#8211; the optimization result</span></a>.</p>
<p>Alternative algorithms can also be used by providing the <code class="docutils literal"><span class="pre">method</span></code>
keyword to the <a class="reference internal" href="#lmfit.minimizer.minimize" title="lmfit.minimizer.minimize"><code class="xref py py-func docutils literal"><span class="pre">minimize()</span></code></a> function or <code class="xref py py-meth docutils literal"><span class="pre">Minimizer.minimize()</span></code>
class as listed in the <a class="reference internal" href="#fit-methods-table"><span>Table of Supported Fitting Methods</span></a>.</p>
<blockquote id="fit-methods-table">
<div><p>Table of Supported Fitting Methods:</p>
<table border="1" class="docutils">
<colgroup>
<col width="26%" />
<col width="74%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Fitting Method</th>
<th class="head"><code class="docutils literal"><span class="pre">method</span></code> arg to <a class="reference internal" href="#lmfit.minimizer.minimize" title="lmfit.minimizer.minimize"><code class="xref py py-func docutils literal"><span class="pre">minimize()</span></code></a> or <code class="xref py py-meth docutils literal"><span class="pre">Minimizer.minimize()</span></code></th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Levenberg-Marquardt</td>
<td><code class="docutils literal"><span class="pre">leastsq</span></code></td>
</tr>
<tr class="row-odd"><td>Nelder-Mead</td>
<td><code class="docutils literal"><span class="pre">nelder</span></code></td>
</tr>
<tr class="row-even"><td>L-BFGS-B</td>
<td><code class="docutils literal"><span class="pre">lbfgsb</span></code></td>
</tr>
<tr class="row-odd"><td>Powell</td>
<td><code class="docutils literal"><span class="pre">powell</span></code></td>
</tr>
<tr class="row-even"><td>Conjugate Gradient</td>
<td><code class="docutils literal"><span class="pre">cg</span></code></td>
</tr>
<tr class="row-odd"><td>Newton-CG</td>
<td><code class="docutils literal"><span class="pre">newton</span></code></td>
</tr>
<tr class="row-even"><td>COBYLA</td>
<td><code class="docutils literal"><span class="pre">cobyla</span></code></td>
</tr>
<tr class="row-odd"><td>Truncated Newton</td>
<td><code class="docutils literal"><span class="pre">tnc</span></code></td>
</tr>
<tr class="row-even"><td>Dogleg</td>
<td><code class="docutils literal"><span class="pre">dogleg</span></code></td>
</tr>
<tr class="row-odd"><td>Sequential Linear
Squares Programming</td>
<td><code class="docutils literal"><span class="pre">slsqp</span></code></td>
</tr>
<tr class="row-even"><td>Differential
Evolution</td>
<td><code class="docutils literal"><span class="pre">differential_evolution</span></code></td>
</tr>
</tbody>
</table>
</div></blockquote>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The objective function for the Levenberg-Marquardt method <strong>must</strong>
return an array, with more elements than variables.  All other methods
can return either a scalar value or an array.</p>
</div>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">Much of this documentation assumes that the Levenberg-Marquardt method is
the method used.  Many of the fit statistics and estimates for
uncertainties in parameters discussed in <a class="reference internal" href="#fit-results-label"><span>MinimizerResult &#8211; the optimization result</span></a> are
done only for this method.</p>
</div>
</div>
<div class="section" id="minimizerresult-the-optimization-result">
<span id="fit-results-label"></span><h2><a class="reference internal" href="#lmfit.minimizer.MinimizerResult" title="lmfit.minimizer.MinimizerResult"><code class="xref py py-class docutils literal"><span class="pre">MinimizerResult</span></code></a> &#8211; the optimization result<a class="headerlink" href="#minimizerresult-the-optimization-result" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="lmfit.minimizer.MinimizerResult">
<em class="property">class </em><code class="descname">MinimizerResult</code><span class="sig-paren">(</span><em>**kws</em><span class="sig-paren">)</span><a class="headerlink" href="#lmfit.minimizer.MinimizerResult" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<div class="versionadded">
<p><span class="versionmodified">New in version 0.9.0.</span></p>
</div>
<p>An optimization with <a class="reference internal" href="#lmfit.minimizer.minimize" title="lmfit.minimizer.minimize"><code class="xref py py-func docutils literal"><span class="pre">minimize()</span></code></a> or <code class="xref py py-meth docutils literal"><span class="pre">Minimizer.minimize()</span></code>
will return a <a class="reference internal" href="#lmfit.minimizer.MinimizerResult" title="lmfit.minimizer.MinimizerResult"><code class="xref py py-class docutils literal"><span class="pre">MinimizerResult</span></code></a> object.  This is an otherwise
plain container object (that is, with no methods of its own) that
simply holds the results of the minimization.  These results will
include several pieces of informational data such as status and error
messages, fit statistics, and the updated parameters themselves.</p>
<p>Importantly, the parameters passed in to <code class="xref py py-meth docutils literal"><span class="pre">Minimizer.minimize()</span></code>
will be not be changed.  To to find the best-fit values, uncertainties
and so on for each parameter, one must use the
<code class="xref py py-attr docutils literal"><span class="pre">MinimizerResult.params</span></code> attribute.</p>
<dl class="attribute">
<dt id="lmfit.minimizer.params">
<code class="descname">params</code><a class="headerlink" href="#lmfit.minimizer.params" title="Permalink to this definition">¶</a></dt>
<dd><p>the <code class="xref py py-class docutils literal"><span class="pre">Parameters</span></code> actually used in the fit, with updated
values, <code class="xref py py-attr docutils literal"><span class="pre">stderr</span></code> and <code class="xref py py-attr docutils literal"><span class="pre">correl</span></code>.</p>
</dd></dl>

<dl class="attribute">
<dt id="lmfit.minimizer.var_names">
<code class="descname">var_names</code><a class="headerlink" href="#lmfit.minimizer.var_names" title="Permalink to this definition">¶</a></dt>
<dd><p>ordered list of variable parameter names used in optimization, and
useful for understanding the the values in <a class="reference internal" href="#lmfit.minimizer.init_vals" title="lmfit.minimizer.init_vals"><code class="xref py py-attr docutils literal"><span class="pre">init_vals</span></code></a> and
<a class="reference internal" href="#lmfit.minimizer.covar" title="lmfit.minimizer.covar"><code class="xref py py-attr docutils literal"><span class="pre">covar</span></code></a>.</p>
</dd></dl>

<dl class="attribute">
<dt id="lmfit.minimizer.covar">
<code class="descname">covar</code><a class="headerlink" href="#lmfit.minimizer.covar" title="Permalink to this definition">¶</a></dt>
<dd><p>covariance matrix from minimization (<cite>leastsq</cite> only), with
rows/columns using <a class="reference internal" href="#lmfit.minimizer.var_names" title="lmfit.minimizer.var_names"><code class="xref py py-attr docutils literal"><span class="pre">var_names</span></code></a>.</p>
</dd></dl>

<dl class="attribute">
<dt id="lmfit.minimizer.init_vals">
<code class="descname">init_vals</code><a class="headerlink" href="#lmfit.minimizer.init_vals" title="Permalink to this definition">¶</a></dt>
<dd><p>list of initial values for variable parameters using <a class="reference internal" href="#lmfit.minimizer.var_names" title="lmfit.minimizer.var_names"><code class="xref py py-attr docutils literal"><span class="pre">var_names</span></code></a>.</p>
</dd></dl>

<dl class="attribute">
<dt id="lmfit.minimizer.nfev">
<code class="descname">nfev</code><a class="headerlink" href="#lmfit.minimizer.nfev" title="Permalink to this definition">¶</a></dt>
<dd><p>number of function evaluations</p>
</dd></dl>

<dl class="attribute">
<dt id="lmfit.minimizer.success">
<code class="descname">success</code><a class="headerlink" href="#lmfit.minimizer.success" title="Permalink to this definition">¶</a></dt>
<dd><p>boolean (<code class="docutils literal"><span class="pre">True</span></code>/<code class="docutils literal"><span class="pre">False</span></code>) for whether fit succeeded.</p>
</dd></dl>

<dl class="attribute">
<dt id="lmfit.minimizer.errorbars">
<code class="descname">errorbars</code><a class="headerlink" href="#lmfit.minimizer.errorbars" title="Permalink to this definition">¶</a></dt>
<dd><p>boolean (<code class="docutils literal"><span class="pre">True</span></code>/<code class="docutils literal"><span class="pre">False</span></code>) for whether uncertainties were
estimated.</p>
</dd></dl>

<dl class="attribute">
<dt id="lmfit.minimizer.message">
<code class="descname">message</code><a class="headerlink" href="#lmfit.minimizer.message" title="Permalink to this definition">¶</a></dt>
<dd><p>message about fit success.</p>
</dd></dl>

<dl class="attribute">
<dt id="lmfit.minimizer.ier">
<code class="descname">ier</code><a class="headerlink" href="#lmfit.minimizer.ier" title="Permalink to this definition">¶</a></dt>
<dd><p>integer error value from <a class="reference external" href="http://docs.scipy.org/doc/scipy/reference/generated/optimize.leastsq.html">optimize.leastsq</a>  (<cite>leastsq</cite>  only).</p>
</dd></dl>

<dl class="attribute">
<dt id="lmfit.minimizer.lmdif_message">
<code class="descname">lmdif_message</code><a class="headerlink" href="#lmfit.minimizer.lmdif_message" title="Permalink to this definition">¶</a></dt>
<dd><p>message from <a class="reference external" href="http://docs.scipy.org/doc/scipy/reference/generated/optimize.leastsq.html">optimize.leastsq</a> (<cite>leastsq</cite> only).</p>
</dd></dl>

<dl class="attribute">
<dt id="lmfit.minimizer.nvarys">
<code class="descname">nvarys</code><a class="headerlink" href="#lmfit.minimizer.nvarys" title="Permalink to this definition">¶</a></dt>
<dd><p>number of variables in fit  <span class="math">\(N_{\rm varys}\)</span></p>
</dd></dl>

<dl class="attribute">
<dt id="lmfit.minimizer.ndata">
<code class="descname">ndata</code><a class="headerlink" href="#lmfit.minimizer.ndata" title="Permalink to this definition">¶</a></dt>
<dd><p>number of data points:  <span class="math">\(N\)</span></p>
</dd></dl>

<dl class="attribute">
<dt>
<code class="descname">nfree `</code></dt>
<dd><p>degrees of freedom in fit:  <span class="math">\(N - N_{\rm varys}\)</span></p>
</dd></dl>

<dl class="attribute">
<dt id="lmfit.minimizer.residual">
<code class="descname">residual</code><a class="headerlink" href="#lmfit.minimizer.residual" title="Permalink to this definition">¶</a></dt>
<dd><p>residual array, return value of <code class="xref py py-func docutils literal"><span class="pre">func()</span></code>:  <span class="math">\({\rm Resid}\)</span></p>
</dd></dl>

<dl class="attribute">
<dt id="lmfit.minimizer.chisqr">
<code class="descname">chisqr</code><a class="headerlink" href="#lmfit.minimizer.chisqr" title="Permalink to this definition">¶</a></dt>
<dd><p>chi-square: <span class="math">\(\chi^2 = \sum_i^N [{\rm Resid}_i]^2\)</span></p>
</dd></dl>

<dl class="attribute">
<dt id="lmfit.minimizer.redchi">
<code class="descname">redchi</code><a class="headerlink" href="#lmfit.minimizer.redchi" title="Permalink to this definition">¶</a></dt>
<dd><p>reduced chi-square: <span class="math">\(\chi^2_{\nu}= {\chi^2} / {(N - N_{\rm
varys})}\)</span></p>
</dd></dl>

<dl class="attribute">
<dt id="lmfit.minimizer.aic">
<code class="descname">aic</code><a class="headerlink" href="#lmfit.minimizer.aic" title="Permalink to this definition">¶</a></dt>
<dd><p>Akaike Information Criterion statistic (see below)</p>
</dd></dl>

<dl class="attribute">
<dt id="lmfit.minimizer.bic">
<code class="descname">bic</code><a class="headerlink" href="#lmfit.minimizer.bic" title="Permalink to this definition">¶</a></dt>
<dd><p>Bayesian Information Criterion statistic (see below).</p>
</dd></dl>

<div class="section" id="goodness-of-fit-statistics">
<h3>Goodness-of-Fit Statistics<a class="headerlink" href="#goodness-of-fit-statistics" title="Permalink to this headline">¶</a></h3>
<blockquote id="goodfit-table">
<div>Table of Fit Results:  These values, including the standard Goodness-of-Fit statistics,
are all attributes of the <a class="reference internal" href="#lmfit.minimizer.MinimizerResult" title="lmfit.minimizer.MinimizerResult"><code class="xref py py-class docutils literal"><span class="pre">MinimizerResult</span></code></a> object returned by
<a class="reference internal" href="#lmfit.minimizer.minimize" title="lmfit.minimizer.minimize"><code class="xref py py-func docutils literal"><span class="pre">minimize()</span></code></a> or <code class="xref py py-meth docutils literal"><span class="pre">Minimizer.minimize()</span></code>.</div></blockquote>
<table border="1" class="docutils">
<colgroup>
<col width="22%" />
<col width="78%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Attribute Name</th>
<th class="head">Description / Formula</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>nfev</td>
<td>number of function evaluations</td>
</tr>
<tr class="row-odd"><td>nvarys</td>
<td>number of variables in fit  <span class="math">\(N_{\rm varys}\)</span></td>
</tr>
<tr class="row-even"><td>ndata</td>
<td>number of data points:  <span class="math">\(N\)</span></td>
</tr>
<tr class="row-odd"><td>nfree `</td>
<td>degrees of freedom in fit:  <span class="math">\(N - N_{\rm varys}\)</span></td>
</tr>
<tr class="row-even"><td>residual</td>
<td>residual array, return value of <code class="xref py py-func docutils literal"><span class="pre">func()</span></code>:  <span class="math">\({\rm Resid}\)</span></td>
</tr>
<tr class="row-odd"><td>chisqr</td>
<td>chi-square: <span class="math">\(\chi^2 = \sum_i^N [{\rm Resid}_i]^2\)</span></td>
</tr>
<tr class="row-even"><td>redchi</td>
<td>reduced chi-square: <span class="math">\(\chi^2_{\nu}= {\chi^2} / {(N - N_{\rm varys})}\)</span></td>
</tr>
<tr class="row-odd"><td>aic</td>
<td>Akaike Information Criterion statistic (see below)</td>
</tr>
<tr class="row-even"><td>bic</td>
<td>Bayesian Information Criterion statistic (see below)</td>
</tr>
<tr class="row-odd"><td>var_names</td>
<td>ordered list of variable parameter names used for init_vals and covar</td>
</tr>
<tr class="row-even"><td>covar</td>
<td>covariance matrix (with rows/columns using var_names</td>
</tr>
<tr class="row-odd"><td>init_vals</td>
<td>list of initial values for variable parameters</td>
</tr>
</tbody>
</table>
<p>Note that the calculation of chi-square and reduced chi-square assume
that the returned residual function is scaled properly to the
uncertainties in the data.  For these statistics to be meaningful, the
person writing the function to be minimized must scale them properly.</p>
<p>After a fit using using the <a class="reference internal" href="#lmfit.minimizer.leastsq" title="lmfit.minimizer.leastsq"><code class="xref py py-meth docutils literal"><span class="pre">leastsq()</span></code></a> method has completed
successfully, standard errors for the fitted variables and correlations
between pairs of fitted variables are automatically calculated from the
covariance matrix.  The standard error (estimated <span class="math">\(1\sigma\)</span>
error-bar) go into the <code class="xref py py-attr docutils literal"><span class="pre">stderr</span></code> attribute of the Parameter.  The
correlations with all other variables will be put into the
<code class="xref py py-attr docutils literal"><span class="pre">correl</span></code> attribute of the Parameter &#8211; a dictionary with keys for
all other Parameters and values of the corresponding correlation.</p>
<p>In some cases, it may not be possible to estimate the errors and
correlations.  For example, if a variable actually has no practical effect
on the fit, it will likely cause the covariance matrix to be singular,
making standard errors impossible to estimate.  Placing bounds on varied
Parameters makes it more likely that errors cannot be estimated, as being
near the maximum or minimum value makes the covariance matrix singular.  In
these cases, the <a class="reference internal" href="#lmfit.minimizer.errorbars" title="lmfit.minimizer.errorbars"><code class="xref py py-attr docutils literal"><span class="pre">errorbars</span></code></a> attribute of the fit result
(<a class="reference internal" href="#lmfit.minimizer.Minimizer" title="lmfit.minimizer.Minimizer"><code class="xref py py-class docutils literal"><span class="pre">Minimizer</span></code></a> object) will be <code class="docutils literal"><span class="pre">False</span></code>.</p>
</div>
<div class="section" id="akaike-and-bayesian-information-criteria">
<span id="information-criteria-label"></span><h3>Akaike and Bayesian Information Criteria<a class="headerlink" href="#akaike-and-bayesian-information-criteria" title="Permalink to this headline">¶</a></h3>
<p>The <a class="reference internal" href="#lmfit.minimizer.MinimizerResult" title="lmfit.minimizer.MinimizerResult"><code class="xref py py-class docutils literal"><span class="pre">MinimizerResult</span></code></a> includes the traditional chi-square and reduced chi-square statistics:</p>
<div class="math">
\[\begin{eqnarray*}
     \chi^2  &amp;=&amp;  \sum_i^N r_i^2 \\
     \chi^2_\nu &amp;=&amp; = \chi^2 / (N-N_{\rm varys})
 \end{eqnarray*}\]</div><p>where <span class="math">\(r\)</span> is the residual array returned by the objective function
(likely to be <code class="docutils literal"><span class="pre">(data-model)/uncertainty</span></code> for data modeling usages),
<span class="math">\(N\)</span> is the number of data points (<code class="docutils literal"><span class="pre">ndata</span></code>), and <span class="math">\(N_{\rm
varys}\)</span> is number of variable parameters.</p>
<p>Also included are the <a class="reference external" href="http://en.wikipedia.org/wiki/Akaike_information_criterion">Akaike Information Criterion</a>, and
<a class="reference external" href="http://en.wikipedia.org/wiki/Bayesian_information_criterion">Bayesian Information Criterion</a> statistics,
held in the <code class="docutils literal"><span class="pre">aic</span></code> and <code class="docutils literal"><span class="pre">bic</span></code> attributes, respectively.  These give slightly
different measures of the relative quality for a fit, trying to balance
quality of fit with the number of variable parameters used in the fit.
These are calculated as</p>
<div class="math">
\[\begin{eqnarray*}
  {\rm aic} &amp;=&amp;  N \ln(\chi^2/N) + 2 N_{\rm varys} \\
  {\rm bic} &amp;=&amp;  N \ln(\chi^2/N) + \ln(N) *N_{\rm varys} \\
 \end{eqnarray*}\]</div><p>When comparing fits with different numbers of varying parameters, one
typically selects the model with lowest reduced chi-square, Akaike
information criterion, and/or Bayesian information criterion.  Generally,
the Bayesian information criterion is considered the most conservative of
these statistics.</p>
</div>
</div>
<div class="section" id="using-a-iteration-callback-function">
<span id="fit-itercb-label"></span><h2>Using a Iteration Callback Function<a class="headerlink" href="#using-a-iteration-callback-function" title="Permalink to this headline">¶</a></h2>
<p>An iteration callback function is a function to be called at each
iteration, just after the objective function is called.  The iteration
callback allows user-supplied code to be run at each iteration, and can be
used to abort a fit.</p>
<dl class="function">
<dt>
<code class="descname">iter_cb(params, iter, resid, *args, **kws):</code></dt>
<dd><p>user-supplied function to be run at each iteration</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>params</strong> (<code class="xref py py-class docutils literal"><span class="pre">Parameters</span></code>.) &#8211; parameters.</li>
<li><strong>iter</strong> (<em>integer</em>) &#8211; iteration number</li>
<li><strong>resid</strong> (<em>ndarray</em>) &#8211; residual array.</li>
<li><strong>args</strong> &#8211; positional arguments.  Must match <code class="docutils literal"><span class="pre">args</span></code> argument to <a class="reference internal" href="#lmfit.minimizer.minimize" title="lmfit.minimizer.minimize"><code class="xref py py-func docutils literal"><span class="pre">minimize()</span></code></a></li>
<li><strong>kws</strong> &#8211; keyword arguments.  Must match <code class="docutils literal"><span class="pre">kws</span></code> argument to <a class="reference internal" href="#lmfit.minimizer.minimize" title="lmfit.minimizer.minimize"><code class="xref py py-func docutils literal"><span class="pre">minimize()</span></code></a></li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">residual array (generally data-model) to be minimized in the least-squares sense.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><code class="docutils literal"><span class="pre">None</span></code> for normal behavior, any value like <code class="docutils literal"><span class="pre">True</span></code> to abort fit.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>Normally, the iteration callback would have no return value or return
<code class="docutils literal"><span class="pre">None</span></code>.  To abort a fit, have this function return a value that is
<code class="docutils literal"><span class="pre">True</span></code> (including any non-zero integer).  The fit will also abort if any
exception is raised in the iteration callback. When a fit is aborted this
way, the parameters will have the values from the last iteration.  The fit
statistics are not likely to be meaningful, and uncertainties will not be computed.</p>
</div>
<div class="section" id="using-the-minimizer-class">
<span id="fit-minimizer-label"></span><h2>Using the <a class="reference internal" href="#lmfit.minimizer.Minimizer" title="lmfit.minimizer.Minimizer"><code class="xref py py-class docutils literal"><span class="pre">Minimizer</span></code></a> class<a class="headerlink" href="#using-the-minimizer-class" title="Permalink to this headline">¶</a></h2>
<p>For full control of the fitting process, you&#8217;ll want to create a
<a class="reference internal" href="#lmfit.minimizer.Minimizer" title="lmfit.minimizer.Minimizer"><code class="xref py py-class docutils literal"><span class="pre">Minimizer</span></code></a> object.</p>
<dl class="class">
<dt id="lmfit.minimizer.Minimizer">
<em class="property">class </em><code class="descname">Minimizer</code><span class="sig-paren">(</span><em>function</em>, <em>params</em>, <em>fcn_args=None</em>, <em>fcn_kws=None</em>, <em>iter_cb=None</em>, <em>scale_covar=True</em>, <em>mask_non_finite=False</em>, <em>**kws</em><span class="sig-paren">)</span><a class="headerlink" href="#lmfit.minimizer.Minimizer" title="Permalink to this definition">¶</a></dt>
<dd><p>creates a Minimizer, for more detailed access to fitting methods and attributes.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>function</strong> (<em>callable.</em>) &#8211; objective function to return fit residual.  See <a class="reference internal" href="#fit-func-label"><span>Writing a Fitting Function</span></a> for details.</li>
<li><strong>params</strong> (<em>dict</em>) &#8211; a dictionary of Parameters.  Keywords must be strings
that match <code class="docutils literal"><span class="pre">[a-z_][a-z0-9_]*</span></code> and is not a python
reserved word.  Each value must be <code class="xref py py-class docutils literal"><span class="pre">Parameter</span></code>.</li>
<li><strong>fcn_args</strong> (<em>tuple</em>) &#8211; arguments tuple to pass to the residual function as  positional arguments.</li>
<li><strong>fcn_kws</strong> (<em>dict</em>) &#8211; dictionary to pass to the residual function as keyword arguments.</li>
<li><strong>iter_cb</strong> (callable or <code class="docutils literal"><span class="pre">None</span></code>) &#8211; function to be called at each fit iteration.  See <a class="reference internal" href="#fit-itercb-label"><span>Using a Iteration Callback Function</span></a> for details.</li>
<li><strong>scale_covar</strong> (bool (default <code class="docutils literal"><span class="pre">True</span></code>).) &#8211; flag for automatically scaling covariance matrix and uncertainties to reduced chi-square (<code class="docutils literal"><span class="pre">leastsq</span></code> only)</li>
<li><strong>nan_policy</strong> (<em>str (default 'raise')</em>) &#8211; <p>Specifies action if <cite>userfcn</cite> (or a Jacobian) returns nan
values. One of:</p>
<blockquote>
<div>&#8216;raise&#8217; - a <cite>ValueError</cite> is raised
&#8216;propagate&#8217; - the values returned from <cite>userfcn</cite> are un-altered
&#8216;omit&#8217; - the non-finite values are filtered.</div></blockquote>
</li>
<li><strong>kws</strong> (<em>dict</em>) &#8211; dictionary to pass as keywords to the underlying <code class="xref py py-mod docutils literal"><span class="pre">scipy.optimize</span></code> method.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>The Minimizer object has a few public methods:</p>
<dl class="method">
<dt>
<code class="descname">minimize</code><span class="sig-paren">(</span><em>method='leastsq'</em>, <em>params=None</em>, <em>**kws</em><span class="sig-paren">)</span></dt>
<dd><p>perform fit using either <a class="reference internal" href="#lmfit.minimizer.leastsq" title="lmfit.minimizer.leastsq"><code class="xref py py-meth docutils literal"><span class="pre">leastsq()</span></code></a> or <a class="reference internal" href="#lmfit.minimizer.scalar_minimize" title="lmfit.minimizer.scalar_minimize"><code class="xref py py-meth docutils literal"><span class="pre">scalar_minimize()</span></code></a>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>method</strong> (<em>str.</em>) &#8211; name of fitting method.  Must be one of the names in
<a class="reference internal" href="#fit-methods-table"><span>Table of Supported Fitting Methods</span></a></li>
<li><strong>params</strong> (<code class="xref py py-class docutils literal"><span class="pre">Parameters</span></code> or <cite>None</cite>) &#8211; a <code class="xref py py-class docutils literal"><span class="pre">Parameters</span></code> dictionary for starting values</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#lmfit.minimizer.MinimizerResult" title="lmfit.minimizer.MinimizerResult"><code class="xref py py-class docutils literal"><span class="pre">MinimizerResult</span></code></a> object, containing updated
parameters, fitting statistics, and information.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<div class="versionchanged">
<p><span class="versionmodified">Changed in version 0.9.0: </span>return value changed to <a class="reference internal" href="#lmfit.minimizer.MinimizerResult" title="lmfit.minimizer.MinimizerResult"><code class="xref py py-class docutils literal"><span class="pre">MinimizerResult</span></code></a></p>
<p>Additional keywords are passed on to the correspond <a class="reference internal" href="#lmfit.minimizer.leastsq" title="lmfit.minimizer.leastsq"><code class="xref py py-meth docutils literal"><span class="pre">leastsq()</span></code></a>
or <a class="reference internal" href="#lmfit.minimizer.scalar_minimize" title="lmfit.minimizer.scalar_minimize"><code class="xref py py-meth docutils literal"><span class="pre">scalar_minimize()</span></code></a> method.</p>
</div>
<dl class="method">
<dt id="lmfit.minimizer.leastsq">
<code class="descname">leastsq</code><span class="sig-paren">(</span><em>params=None</em>, <em>scale_covar=True</em>, <em>**kws</em><span class="sig-paren">)</span><a class="headerlink" href="#lmfit.minimizer.leastsq" title="Permalink to this definition">¶</a></dt>
<dd><p>perform fit with Levenberg-Marquardt algorithm.  Keywords will be
passed directly to <a class="reference external" href="http://docs.scipy.org/doc/scipy/reference/generated/optimize.leastsq.html">optimize.leastsq</a>.  By default,
numerical derivatives are used, and the following arguments are set:</p>
<blockquote>
<div><table border="1" class="docutils">
<colgroup>
<col width="19%" />
<col width="17%" />
<col width="64%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head"><a class="reference internal" href="#lmfit.minimizer.leastsq" title="lmfit.minimizer.leastsq"><code class="xref py py-meth docutils literal"><span class="pre">leastsq()</span></code></a>
arg</th>
<th class="head">Default Value</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>xtol</td>
<td>1.e-7</td>
<td>Relative error in the approximate solution</td>
</tr>
<tr class="row-odd"><td>ftol</td>
<td>1.e-7</td>
<td>Relative error in the desired sum of squares</td>
</tr>
<tr class="row-even"><td>maxfev</td>
<td>2000*(nvar+1)</td>
<td>maximum number of function calls (nvar= # of variables)</td>
</tr>
<tr class="row-odd"><td>Dfun</td>
<td><code class="docutils literal"><span class="pre">None</span></code></td>
<td>function to call for Jacobian calculation</td>
</tr>
</tbody>
</table>
</div></blockquote>
</dd></dl>

<div class="versionchanged">
<p><span class="versionmodified">Changed in version 0.9.0: </span>return value changed to <a class="reference internal" href="#lmfit.minimizer.MinimizerResult" title="lmfit.minimizer.MinimizerResult"><code class="xref py py-class docutils literal"><span class="pre">MinimizerResult</span></code></a></p>
</div>
<dl class="method">
<dt id="lmfit.minimizer.scalar_minimize">
<code class="descname">scalar_minimize</code><span class="sig-paren">(</span><em>method='Nelder-Mead'</em>, <em>params=None</em>, <em>hess=None</em>, <em>tol=None</em>, <em>**kws</em><span class="sig-paren">)</span><a class="headerlink" href="#lmfit.minimizer.scalar_minimize" title="Permalink to this definition">¶</a></dt>
<dd><p>perform fit with any of the scalar minimization algorithms supported by
<a class="reference external" href="http://docs.scipy.org/doc/scipy/reference/generated/optimize.minimize.html">optimize.minimize</a>.</p>
<blockquote>
<div><table border="1" class="docutils">
<colgroup>
<col width="26%" />
<col width="18%" />
<col width="56%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head"><a class="reference internal" href="#lmfit.minimizer.scalar_minimize" title="lmfit.minimizer.scalar_minimize"><code class="xref py py-meth docutils literal"><span class="pre">scalar_minimize()</span></code></a>
arg</th>
<th class="head">Default Value</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>method</td>
<td><code class="docutils literal"><span class="pre">Nelder-Mead</span></code></td>
<td>fitting method</td>
</tr>
<tr class="row-odd"><td>tol</td>
<td>1.e-7</td>
<td>fitting and parameter tolerance</td>
</tr>
<tr class="row-even"><td>hess</td>
<td>None</td>
<td>Hessian of objective function</td>
</tr>
</tbody>
</table>
</div></blockquote>
</dd></dl>

<div class="versionchanged">
<p><span class="versionmodified">Changed in version 0.9.0: </span>return value changed to <a class="reference internal" href="#lmfit.minimizer.MinimizerResult" title="lmfit.minimizer.MinimizerResult"><code class="xref py py-class docutils literal"><span class="pre">MinimizerResult</span></code></a></p>
</div>
<dl class="method">
<dt id="lmfit.minimizer.prepare_fit">
<code class="descname">prepare_fit</code><span class="sig-paren">(</span><em>**kws</em><span class="sig-paren">)</span><a class="headerlink" href="#lmfit.minimizer.prepare_fit" title="Permalink to this definition">¶</a></dt>
<dd><p>prepares and initializes model and Parameters for subsequent
fitting. This routine prepares the conversion of <code class="xref py py-class docutils literal"><span class="pre">Parameters</span></code>
into fit variables, organizes parameter bounds, and parses, &#8220;compiles&#8221;
and checks constrain expressions.   The method also creates and returns
a new instance of a <a class="reference internal" href="#lmfit.minimizer.MinimizerResult" title="lmfit.minimizer.MinimizerResult"><code class="xref py py-class docutils literal"><span class="pre">MinimizerResult</span></code></a> object that contains the
copy of the Parameters that will actually be varied in the fit.</p>
<p>This method is called directly by the fitting methods, and it is
generally not necessary to call this function explicitly.</p>
</dd></dl>

<div class="versionchanged">
<p><span class="versionmodified">Changed in version 0.9.0: </span>return value changed to <a class="reference internal" href="#lmfit.minimizer.MinimizerResult" title="lmfit.minimizer.MinimizerResult"><code class="xref py py-class docutils literal"><span class="pre">MinimizerResult</span></code></a></p>
</div>
<dl class="method">
<dt id="lmfit.minimizer.emcee">
<code class="descname">emcee</code><span class="sig-paren">(</span><em>params=None</em>, <em>steps=1000</em>, <em>nwalkers=100</em>, <em>burn=0</em>, <em>thin=1</em>, <em>ntemps=1</em>, <em>pos=None</em>, <em>reuse_sampler=False</em>, <em>workers=1</em>, <em>float_behavior='posterior'</em>, <em>is_weighted=True</em>, <em>seed=None</em><span class="sig-paren">)</span><a class="headerlink" href="#lmfit.minimizer.emcee" title="Permalink to this definition">¶</a></dt>
<dd><p>Bayesian sampling of the posterior distribution for the parameters using the <cite>emcee</cite>
Markov Chain Monte Carlo package. The method assumes that the prior is Uniform. You need
to have <cite>emcee</cite> installed to use this method.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>params</strong> (<code class="xref py py-class docutils literal"><span class="pre">Parameters</span></code> or <cite>None</cite>) &#8211; a <code class="xref py py-class docutils literal"><span class="pre">Parameters</span></code> dictionary for starting values</li>
<li><strong>steps</strong> (<em>int</em>) &#8211; How many samples you would like to draw from the posterior
distribution for each of the walkers?</li>
<li><strong>nwalkers</strong> (<em>int</em>) &#8211; Should be set so <span class="math">\(nwalkers &gt;&gt; nvarys\)</span>, where <cite>nvarys</cite>
are the number of parameters being varied during the fit.
&#8220;Walkers are the members of the ensemble. They are almost
like separate Metropolis-Hastings chains but, of course,
the proposal distribution for a given walker depends on the
positions of all the other walkers in the ensemble.&#8221; - from
<a class="footnote-reference" href="#id3" id="id1">[1]</a>.</li>
<li><strong>burn</strong> (<em>int</em>) &#8211; Discard this many samples from the start of the sampling regime.</li>
<li><strong>thin</strong> (<em>int</em>) &#8211; Only accept 1 in every <cite>thin</cite> samples.</li>
<li><strong>ntemps</strong> (<em>int</em>) &#8211; If <cite>ntemps &gt; 1</cite> perform a Parallel Tempering.</li>
<li><strong>pos</strong> (<em>np.ndarray</em>) &#8211; Specify the initial positions for the sampler.  If <cite>ntemps == 1</cite>
then <cite>pos.shape</cite> should be <cite>(nwalkers, nvarys)</cite>. Otherwise,
<cite>(ntemps, nwalkers, nvarys)</cite>. You can also initialise using a
previous chain that had the same <cite>ntemps</cite>, <cite>nwalkers</cite> and <cite>nvarys</cite>.</li>
<li><strong>reuse_sampler</strong> (<em>bool</em>) &#8211; If you have already run <a class="reference internal" href="#lmfit.minimizer.emcee" title="lmfit.minimizer.emcee"><code class="xref py py-meth docutils literal"><span class="pre">emcee()</span></code></a> on a given
<a class="reference internal" href="#lmfit.minimizer.Minimizer" title="lmfit.minimizer.Minimizer"><code class="xref py py-class docutils literal"><span class="pre">Minimizer</span></code></a> object then it possesses an internal sampler
attribute. You can continue to draw from the same sampler (retaining
the chain history) if you set this option to <cite>True</cite>. Otherwise a new
sampler is created. The <cite>nwalkers</cite>, <cite>ntemps</cite> and <cite>params</cite> keywords
are ignored with this option.
<strong>Important</strong>: the <code class="xref py py-class docutils literal"><span class="pre">Parameters</span></code> used to create the sampler
must not change in-between calls to <a class="reference internal" href="#lmfit.minimizer.emcee" title="lmfit.minimizer.emcee"><code class="xref py py-meth docutils literal"><span class="pre">emcee()</span></code></a>. Alteration of
<code class="xref py py-class docutils literal"><span class="pre">Parameters</span></code> would include changed <code class="docutils literal"><span class="pre">min</span></code>, <code class="docutils literal"><span class="pre">max</span></code>,
<code class="docutils literal"><span class="pre">vary</span></code> and <code class="docutils literal"><span class="pre">expr</span></code> attributes. This may happen, for example, if
you use an altered <code class="xref py py-class docutils literal"><span class="pre">Parameters</span></code> object and call the
<a class="reference internal" href="#lmfit.minimizer.minimize" title="lmfit.minimizer.minimize"><code class="xref py py-meth docutils literal"><span class="pre">minimize()</span></code></a> method in-between calls to <a class="reference internal" href="#lmfit.minimizer.emcee" title="lmfit.minimizer.emcee"><code class="xref py py-meth docutils literal"><span class="pre">emcee()</span></code></a> .</li>
<li><strong>workers</strong> (<em>int or Pool-like</em>) &#8211; For parallelization of sampling.  It can be any Pool-like object
with a map method that follows the same calling sequence as the
built-in map function. If int is given as the argument, then a
multiprocessing-based pool is spawned internally with the
corresponding number of parallel processes. &#8216;mpi4py&#8217;-based
parallelization and &#8216;joblib&#8217;-based parallelization pools can also
be used here. <strong>Note</strong>: because of multiprocessing overhead it may
only be worth parallelising if the objective function is expensive
to calculate, or if there are a large number of objective
evaluations per step (<cite>ntemps * nwalkers * nvarys</cite>).</li>
<li><strong>float_behavior</strong> (<em>str</em>) &#8211; <p>Specifies the meaning of the objective function if it
returns a float. One of:</p>
<blockquote>
<div>&#8216;posterior&#8217; - the objective function returns a log-posterior probability<p>&#8216;chi2&#8217; - the objective function is returning <span class="math">\(\chi^2\)</span>.</p>
</div></blockquote>
<p>See Notes for further details.</p>
</li>
<li><strong>is_weighted</strong> (<em>bool</em>) &#8211; Has your objective function been weighted by measurement
uncertainties? If <cite>is_weighted is True</cite> then your objective
function is assumed to return residuals that have been divided by
the true measurement uncertainty <cite>(data - model) / sigma</cite>. If
<cite>is_weighted is False</cite> then the objective function is assumed to
return unweighted residuals, <cite>data - model</cite>. In this case <cite>emcee</cite>
will employ a positive measurement uncertainty during the sampling.
This measurement uncertainty will be present in the output params
and output chain with the name <cite>__lnsigma</cite>. A side effect of this
is that you cannot use this parameter name yourself.
<strong>Important</strong> this parameter only has any effect if your objective
function returns an array. If your objective function returns a
float, then this parameter is ignored. See Notes for more details.</li>
<li><strong>seed</strong> (<em>int or np.random.RandomState</em>) &#8211; If <cite>seed</cite> is an int, a new <cite>np.random.RandomState</cite> instance is used,
seeded with <cite>seed</cite>.
If <cite>seed</cite> is already a <cite>np.random.RandomState</cite> instance, then that
<cite>np.random.RandomState</cite> instance is used.
Specify <cite>seed</cite> for repeatable sampling.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#lmfit.minimizer.MinimizerResult" title="lmfit.minimizer.MinimizerResult"><code class="xref py py-class docutils literal"><span class="pre">MinimizerResult</span></code></a> object containing updated params, statistics,
etc. The <a class="reference internal" href="#lmfit.minimizer.MinimizerResult" title="lmfit.minimizer.MinimizerResult"><code class="xref py py-class docutils literal"><span class="pre">MinimizerResult</span></code></a> also contains the <code class="docutils literal"><span class="pre">chain</span></code>,
<code class="docutils literal"><span class="pre">flatchain</span></code> and <code class="docutils literal"><span class="pre">lnprob</span></code> attributes. The <code class="docutils literal"><span class="pre">chain</span></code>
and <code class="docutils literal"><span class="pre">flatchain</span></code> attributes contain the samples and have the shape
<cite>(nwalkers, (steps - burn) // thin, nvarys)</cite> or
<cite>(ntemps, nwalkers, (steps - burn) // thin, nvarys)</cite>,
depending on whether Parallel tempering was used or not.
<cite>nvarys</cite> is the number of parameters that are allowed to vary.
The <code class="docutils literal"><span class="pre">flatchain</span></code> attribute is a <code class="xref py py-class docutils literal"><span class="pre">pandas.DataFrame</span></code> of the
flattened chain, <cite>chain.reshape(-1, nvarys)</cite>. To access flattened
chain values for a particular parameter use
<cite>result.flatchain[parname]</cite>. The <code class="docutils literal"><span class="pre">lnprob</span></code> attribute contains the
log probability for each sample in <code class="docutils literal"><span class="pre">chain</span></code>. The sample with the
highest probability corresponds to the maximum likelihood estimate.</p>
</td>
</tr>
</tbody>
</table>
<p>This method samples the posterior distribution of the parameters using
Markov Chain Monte Carlo.  To do so it needs to calculate the
log-posterior probability of the model parameters, <cite>F</cite>, given the data,
<cite>D</cite>, <span class="math">\(\ln p(F_{true} | D)\)</span>. This &#8216;posterior probability&#8217; is
calculated as:</p>
<div class="math">
\[\ln p(F_{true} | D) \propto \ln p(D | F_{true}) + \ln p(F_{true})\]</div>
<p>where <span class="math">\(\ln p(D | F_{true})\)</span> is the &#8216;log-likelihood&#8217; and
<span class="math">\(\ln p(F_{true})\)</span> is the &#8216;log-prior&#8217;. The default log-prior
encodes prior information already known about the model. This method
assumes that the log-prior probability is <cite>-np.inf</cite> (impossible) if the
one of the parameters is outside its limits. The log-prior probability
term is zero if all the parameters are inside their bounds (known as a
uniform prior). The log-likelihood function is given by <a class="footnote-reference" href="#id3" id="id2">[1]</a>:</p>
<div class="math">
\[\ln p(D|F_{true}) = -\frac{1}{2}\sum_n \left[\frac{\left(g_n(F_{true}) - D_n \right)^2}{s_n^2}+\ln (2\pi s_n^2)\right]\]</div>
<p>The first summand in the square brackets represents the residual for a
given datapoint (<span class="math">\(g\)</span> being the generative model) . This term
represents <span class="math">\(\chi^2\)</span> when summed over all datapoints.
Ideally the objective function used to create <code class="xref py py-class docutils literal"><span class="pre">lmfit.Minimizer</span></code> should
return the log-posterior probability, <span class="math">\(\ln p(F_{true} | D)\)</span>.
However, since the in-built log-prior term is zero, the objective
function can also just return the log-likelihood, unless you wish to
create a non-uniform prior.</p>
<p>If a float value is returned by the objective function then this value
is assumed by default to be the log-posterior probability, i.e.
<cite>float_behavior is &#8216;posterior&#8217;</cite>. If your objective function returns
<span class="math">\(\chi^2\)</span>, then you should use a value of <cite>&#8216;chi2&#8217;</cite> for
<cite>float_behavior</cite>. <cite>emcee</cite> will then multiply your <span class="math">\(\chi^2\)</span> value
by -0.5 to obtain the posterior probability.</p>
<p>However, the default behaviour of many objective functions is to return
a vector of (possibly weighted) residuals. Therefore, if your objective
function returns a vector, <cite>res</cite>, then the vector is assumed to contain
the residuals. If <cite>is_weighted is True</cite> then your residuals are assumed
to be correctly weighted by the standard deviation of the data points
(<cite>res = (data - model) / sigma</cite>) and the log-likelihood (and
log-posterior probability) is calculated as: <cite>-0.5 * np.sum(res **2)</cite>.
This ignores the second summand in the square brackets. Consequently, in
order to calculate a fully correct log-posterior probability value your
objective function should return a single value. If <cite>is_weighted is False</cite>
then the data uncertainty, <span class="math">\(s_n\)</span>, will be treated as a nuisance
parameter and will be marginalised out. This is achieved by employing a
strictly positive uncertainty (homoscedasticity) for each data point,
<span class="math">\(s_n=exp(\_\_lnsigma)\)</span>. <cite>__lnsigma</cite> will be present in
<cite>MinimizerResult.params</cite>, as well as <cite>Minimizer.chain</cite>, <cite>nvarys</cite> will also be
increased by one.</p>
<table class="docutils footnote" frame="void" id="id3" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[1]</td><td><em>(<a class="fn-backref" href="#id1">1</a>, <a class="fn-backref" href="#id2">2</a>)</em> <a class="reference external" href="http://dan.iel.fm/emcee/current/user/line/">http://dan.iel.fm/emcee/current/user/line/</a></td></tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="emcee-calculating-the-posterior-probability-distribution-of-parameters">
<span id="label-emcee"></span><h2><a class="reference internal" href="#lmfit.minimizer.emcee" title="lmfit.minimizer.emcee"><code class="xref py py-meth docutils literal"><span class="pre">emcee()</span></code></a> - calculating the posterior probability distribution of parameters<a class="headerlink" href="#emcee-calculating-the-posterior-probability-distribution-of-parameters" title="Permalink to this headline">¶</a></h2>
<p><a class="reference internal" href="#lmfit.minimizer.emcee" title="lmfit.minimizer.emcee"><code class="xref py py-meth docutils literal"><span class="pre">emcee()</span></code></a> can be used to obtain the posterior probability distribution of
parameters, given a set of experimental data. An example problem is a double
exponential decay. A small amount of Gaussian noise is also added in:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">lmfit</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="kn">as</span> <span class="nn">plt</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">250</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="mf">3.0</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">x</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span> <span class="o">-</span> <span class="mf">5.0</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="mf">0.1</span><span class="p">)</span> <span class="o">/</span> <span class="mf">10.</span><span class="p">)</span> <span class="o">+</span> <span class="mf">0.1</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
<img alt="_images/emcee_dbl_exp.png" src="_images/emcee_dbl_exp.png" />
<p>Create a Parameter set for the initial guesses:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">p</span> <span class="o">=</span> <span class="n">lmfit</span><span class="o">.</span><span class="n">Parameters</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span><span class="o">.</span><span class="n">add_many</span><span class="p">((</span><span class="s1">&#39;a1&#39;</span><span class="p">,</span> <span class="mf">4.</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;a2&#39;</span><span class="p">,</span> <span class="mf">4.</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;t1&#39;</span><span class="p">,</span> <span class="mf">3.</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;t2&#39;</span><span class="p">,</span> <span class="mf">3.</span><span class="p">,</span> <span class="bp">True</span><span class="p">))</span>

<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">residual</span><span class="p">(</span><span class="n">p</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">v</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">valuesdict</span><span class="p">()</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="n">v</span><span class="p">[</span><span class="s1">&#39;a1&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">x</span> <span class="o">/</span> <span class="n">v</span><span class="p">[</span><span class="s1">&#39;t1&#39;</span><span class="p">])</span> <span class="o">+</span> <span class="n">v</span><span class="p">[</span><span class="s1">&#39;a2&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="mf">0.1</span><span class="p">)</span> <span class="o">/</span> <span class="n">v</span><span class="p">[</span><span class="s1">&#39;t2&#39;</span><span class="p">])</span> <span class="o">-</span> <span class="n">y</span>
</pre></div>
</div>
<p>Solving with <a class="reference internal" href="#lmfit.minimizer.minimize" title="lmfit.minimizer.minimize"><code class="xref py py-func docutils literal"><span class="pre">minimize()</span></code></a> gives the Maximum Likelihood solution.:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">mi</span> <span class="o">=</span> <span class="n">lmfit</span><span class="o">.</span><span class="n">minimize</span><span class="p">(</span><span class="n">residual</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;Nelder&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">lmfit</span><span class="o">.</span><span class="n">printfuncs</span><span class="o">.</span><span class="n">report_fit</span><span class="p">(</span><span class="n">mi</span><span class="o">.</span><span class="n">params</span><span class="p">,</span> <span class="n">min_correl</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>
<span class="go">[[Variables]]</span>
<span class="go">    a1:   2.98623688 (init= 4)</span>
<span class="go">    a2:  -4.33525596 (init= 4)</span>
<span class="go">    t1:   1.30993185 (init= 3)</span>
<span class="go">    t2:   11.8240752 (init= 3)</span>
<span class="go">[[Correlations]] (unreported correlations are &lt;  0.500)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">residual</span><span class="p">(</span><span class="n">mi</span><span class="o">.</span><span class="n">params</span><span class="p">)</span> <span class="o">+</span> <span class="n">y</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
<img alt="_images/emcee_dbl_exp2.png" src="_images/emcee_dbl_exp2.png" />
<p>However, this doesn&#8217;t give a probability distribution for the parameters.
Furthermore, we wish to deal with the data uncertainty. This is called
marginalisation of a nuisance parameter. emcee requires a function that returns
the log-posterior probability. The log-posterior probability is a sum of the
log-prior probability and log-likelihood functions. The log-prior probability is
assumed to be zero if all the parameters are within their bounds and <cite>-np.inf</cite>
if any of the parameters are outside their bounds.:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="c1"># add a noise parameter</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mi</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="s1">&#39;f&#39;</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="nb">min</span><span class="o">=</span><span class="mf">0.001</span><span class="p">,</span> <span class="nb">max</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>

<span class="gp">&gt;&gt;&gt; </span><span class="c1"># This is the log-likelihood probability for the sampling. We&#39;re going to estimate the</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># size of the uncertainties on the data as well.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">lnprob</span><span class="p">(</span><span class="n">p</span><span class="p">):</span>
<span class="gp">... </span>   <span class="n">resid</span> <span class="o">=</span> <span class="n">residual</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
<span class="gp">... </span>   <span class="n">s</span> <span class="o">=</span> <span class="n">p</span><span class="p">[</span><span class="s1">&#39;f&#39;</span><span class="p">]</span>
<span class="gp">... </span>   <span class="n">resid</span> <span class="o">*=</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">s</span>
<span class="gp">... </span>   <span class="n">resid</span> <span class="o">*=</span> <span class="n">resid</span>
<span class="gp">... </span>   <span class="n">resid</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">s</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">... </span>   <span class="k">return</span> <span class="o">-</span><span class="mf">0.5</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">resid</span><span class="p">)</span>
</pre></div>
</div>
<p>Now we have to set up the minimizer and do the sampling.:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">mini</span> <span class="o">=</span> <span class="n">lmfit</span><span class="o">.</span><span class="n">Minimizer</span><span class="p">(</span><span class="n">lnprob</span><span class="p">,</span> <span class="n">mi</span><span class="o">.</span><span class="n">params</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">res</span> <span class="o">=</span> <span class="n">mini</span><span class="o">.</span><span class="n">emcee</span><span class="p">(</span><span class="n">burn</span><span class="o">=</span><span class="mi">300</span><span class="p">,</span> <span class="n">steps</span><span class="o">=</span><span class="mi">600</span><span class="p">,</span> <span class="n">thin</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">params</span><span class="o">=</span><span class="n">mi</span><span class="o">.</span><span class="n">params</span><span class="p">)</span>
</pre></div>
</div>
<p>Lets have a look at those posterior distributions for the parameters.  This requires
installation of the <cite>corner</cite> package.:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">corner</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">corner</span><span class="o">.</span><span class="n">corner</span><span class="p">(</span><span class="n">res</span><span class="o">.</span><span class="n">flatchain</span><span class="p">,</span> <span class="n">labels</span><span class="o">=</span><span class="n">res</span><span class="o">.</span><span class="n">var_names</span><span class="p">,</span> <span class="n">truths</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="n">res</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">valuesdict</span><span class="p">()</span><span class="o">.</span><span class="n">values</span><span class="p">()))</span>
</pre></div>
</div>
<img alt="_images/emcee_triangle.png" src="_images/emcee_triangle.png" />
<p>The values reported in the <a class="reference internal" href="#lmfit.minimizer.MinimizerResult" title="lmfit.minimizer.MinimizerResult"><code class="xref py py-class docutils literal"><span class="pre">MinimizerResult</span></code></a> are the medians of the
probability distributions and a 1 sigma quantile, estimated as half the
difference between the 15.8 and 84.2 percentiles. The median value is not
necessarily the same as the Maximum Likelihood Estimate. We&#8217;ll get that as well.
You can see that we recovered the right uncertainty level on the data.:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="s2">&quot;median of posterior probability distribution&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="s1">&#39;------------------------------------------&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">lmfit</span><span class="o">.</span><span class="n">report_fit</span><span class="p">(</span><span class="n">res</span><span class="o">.</span><span class="n">params</span><span class="p">)</span>
<span class="go">median of posterior probability distribution</span>
<span class="go">------------------------------------------</span>
<span class="go">[[Variables]]</span>
<span class="go">    a1:   3.00975345 +/- 0.151034 (5.02%) (init= 2.986237)</span>
<span class="go">    a2:  -4.35419204 +/- 0.127505 (2.93%) (init=-4.335256)</span>
<span class="go">    t1:   1.32726415 +/- 0.142995 (10.77%) (init= 1.309932)</span>
<span class="go">    t2:   11.7911935 +/- 0.495583 (4.20%) (init= 11.82408)</span>
<span class="go">    f:    0.09805494 +/- 0.004256 (4.34%) (init= 1)</span>
<span class="go">[[Correlations]] (unreported correlations are &lt;  0.100)</span>
<span class="go">    C(a2, t2)                    =  0.981</span>
<span class="go">    C(a2, t1)                    = -0.927</span>
<span class="go">    C(t1, t2)                    = -0.880</span>
<span class="go">    C(a1, t1)                    = -0.519</span>
<span class="go">    C(a1, a2)                    =  0.195</span>
<span class="go">    C(a1, t2)                    =  0.146</span>

<span class="gp">&gt;&gt;&gt; </span><span class="c1"># find the maximum likelihood solution</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">highest_prob</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">res</span><span class="o">.</span><span class="n">lnprob</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hp_loc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unravel_index</span><span class="p">(</span><span class="n">highest_prob</span><span class="p">,</span> <span class="n">res</span><span class="o">.</span><span class="n">lnprob</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mle_soln</span> <span class="o">=</span> <span class="n">res</span><span class="o">.</span><span class="n">chain</span><span class="p">[</span><span class="n">hp_loc</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">par</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">p</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">p</span><span class="p">[</span><span class="n">par</span><span class="p">]</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">mle_soln</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Maximum likelihood Estimation&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="s1">&#39;-----------------------------&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
<span class="go">Maximum likelihood Estimation</span>
<span class="go">-----------------------------</span>
<span class="go">Parameters([(&#39;a1&#39;, &lt;Parameter &#39;a1&#39;, 2.9943337359308981, bounds=[-inf:inf]&gt;),</span>
<span class="go">(&#39;a2&#39;, &lt;Parameter &#39;a2&#39;, -4.3364489105166593, bounds=[-inf:inf]&gt;),</span>
<span class="go">(&#39;t1&#39;, &lt;Parameter &#39;t1&#39;, 1.3124544105342462, bounds=[-inf:inf]&gt;),</span>
<span class="go">(&#39;t2&#39;, &lt;Parameter &#39;t2&#39;, 11.80612160586597, bounds=[-inf:inf]&gt;)])</span>

<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Finally lets work out a 1 and 2-sigma error estimate for &#39;t1&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">quantiles</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">res</span><span class="o">.</span><span class="n">flatchain</span><span class="p">[</span><span class="s1">&#39;t1&#39;</span><span class="p">],</span> <span class="p">[</span><span class="mf">2.28</span><span class="p">,</span> <span class="mf">15.9</span><span class="p">,</span> <span class="mi">50</span><span class="p">,</span> <span class="mf">84.2</span><span class="p">,</span> <span class="mf">97.7</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="s2">&quot;2 sigma spread&quot;</span><span class="p">,</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="n">quantiles</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">quantiles</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
<span class="go">2 sigma spread 0.298878202908</span>
</pre></div>
</div>
</div>
<div class="section" id="getting-and-printing-fit-reports">
<h2>Getting and Printing Fit Reports<a class="headerlink" href="#getting-and-printing-fit-reports" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="lmfit.printfuncs.fit_report">
<code class="descname">fit_report</code><span class="sig-paren">(</span><em>result</em>, <em>modelpars=None</em>, <em>show_correl=True</em>, <em>min_correl=0.1</em><span class="sig-paren">)</span><a class="headerlink" href="#lmfit.printfuncs.fit_report" title="Permalink to this definition">¶</a></dt>
<dd><p>generate and return text of report of best-fit values, uncertainties,
and correlations from fit.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>result</strong> &#8211; <code class="xref py py-class docutils literal"><span class="pre">MinimizerResult</span></code> object as returned by <code class="xref py py-func docutils literal"><span class="pre">minimize()</span></code>.</li>
<li><strong>modelpars</strong> &#8211; Parameters with &#8220;Known Values&#8221; (optional, default None)</li>
<li><strong>show_correl</strong> &#8211; whether to show list of sorted correlations [<code class="docutils literal"><span class="pre">True</span></code>]</li>
<li><strong>min_correl</strong> &#8211; smallest correlation absolute value to show [0.1]</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>If the first argument is a <code class="xref py py-class docutils literal"><span class="pre">Parameters</span></code> object,
goodness-of-fit statistics will not be included.</p>
</dd></dl>

<dl class="function">
<dt id="lmfit.printfuncs.report_fit">
<code class="descname">report_fit</code><span class="sig-paren">(</span><em>result</em>, <em>modelpars=None</em>, <em>show_correl=True</em>, <em>min_correl=0.1</em><span class="sig-paren">)</span><a class="headerlink" href="#lmfit.printfuncs.report_fit" title="Permalink to this definition">¶</a></dt>
<dd><p>print text of report from <a class="reference internal" href="#lmfit.printfuncs.fit_report" title="lmfit.printfuncs.fit_report"><code class="xref py py-func docutils literal"><span class="pre">fit_report()</span></code></a>.</p>
</dd></dl>

<p>An example fit with report would be</p>
<div class="highlight-python"><div class="highlight"><pre><span class="ch">#!/usr/bin/env python</span>
<span class="c1">#&lt;examples/doc_withreport.py&gt;</span>

<span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">print_function</span>
<span class="kn">from</span> <span class="nn">lmfit</span> <span class="kn">import</span> <span class="n">Parameters</span><span class="p">,</span> <span class="n">minimize</span><span class="p">,</span> <span class="n">fit_report</span>
<span class="kn">from</span> <span class="nn">numpy</span> <span class="kn">import</span> <span class="n">random</span><span class="p">,</span> <span class="n">linspace</span><span class="p">,</span> <span class="n">pi</span><span class="p">,</span> <span class="n">exp</span><span class="p">,</span> <span class="n">sin</span><span class="p">,</span> <span class="n">sign</span>


<span class="n">p_true</span> <span class="o">=</span> <span class="n">Parameters</span><span class="p">()</span>
<span class="n">p_true</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="s1">&#39;amp&#39;</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="mf">14.0</span><span class="p">)</span>
<span class="n">p_true</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="s1">&#39;period&#39;</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="mf">5.46</span><span class="p">)</span>
<span class="n">p_true</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="s1">&#39;shift&#39;</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="mf">0.123</span><span class="p">)</span>
<span class="n">p_true</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="s1">&#39;decay&#39;</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="mf">0.032</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">residual</span><span class="p">(</span><span class="n">pars</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="n">vals</span> <span class="o">=</span> <span class="n">pars</span><span class="o">.</span><span class="n">valuesdict</span><span class="p">()</span>
    <span class="n">amp</span> <span class="o">=</span>  <span class="n">vals</span><span class="p">[</span><span class="s1">&#39;amp&#39;</span><span class="p">]</span>
    <span class="n">per</span> <span class="o">=</span>  <span class="n">vals</span><span class="p">[</span><span class="s1">&#39;period&#39;</span><span class="p">]</span>
    <span class="n">shift</span> <span class="o">=</span> <span class="n">vals</span><span class="p">[</span><span class="s1">&#39;shift&#39;</span><span class="p">]</span>
    <span class="n">decay</span> <span class="o">=</span> <span class="n">vals</span><span class="p">[</span><span class="s1">&#39;decay&#39;</span><span class="p">]</span>

    <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">shift</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">pi</span><span class="o">/</span><span class="mi">2</span><span class="p">:</span>
        <span class="n">shift</span> <span class="o">=</span> <span class="n">shift</span> <span class="o">-</span> <span class="n">sign</span><span class="p">(</span><span class="n">shift</span><span class="p">)</span><span class="o">*</span><span class="n">pi</span>
    <span class="n">model</span> <span class="o">=</span> <span class="n">amp</span> <span class="o">*</span> <span class="n">sin</span><span class="p">(</span><span class="n">shift</span> <span class="o">+</span> <span class="n">x</span><span class="o">/</span><span class="n">per</span><span class="p">)</span> <span class="o">*</span> <span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">x</span><span class="o">*</span><span class="n">x</span><span class="o">*</span><span class="n">decay</span><span class="o">*</span><span class="n">decay</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">data</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">model</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">model</span> <span class="o">-</span> <span class="n">data</span><span class="p">)</span>

<span class="n">n</span> <span class="o">=</span> <span class="mi">1001</span>
<span class="n">xmin</span> <span class="o">=</span> <span class="mf">0.</span>
<span class="n">xmax</span> <span class="o">=</span> <span class="mf">250.0</span>

<span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

<span class="n">noise</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="n">scale</span><span class="o">=</span><span class="mf">0.7215</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="n">n</span><span class="p">)</span>
<span class="n">x</span>     <span class="o">=</span> <span class="n">linspace</span><span class="p">(</span><span class="n">xmin</span><span class="p">,</span> <span class="n">xmax</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
<span class="n">data</span>  <span class="o">=</span> <span class="n">residual</span><span class="p">(</span><span class="n">p_true</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="n">noise</span>

<span class="n">fit_params</span> <span class="o">=</span> <span class="n">Parameters</span><span class="p">()</span>
<span class="n">fit_params</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="s1">&#39;amp&#39;</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="mf">13.0</span><span class="p">)</span>
<span class="n">fit_params</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="s1">&#39;period&#39;</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="n">fit_params</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="s1">&#39;shift&#39;</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="mf">0.0</span><span class="p">)</span>
<span class="n">fit_params</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="s1">&#39;decay&#39;</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="mf">0.02</span><span class="p">)</span>

<span class="n">out</span> <span class="o">=</span> <span class="n">minimize</span><span class="p">(</span><span class="n">residual</span><span class="p">,</span> <span class="n">fit_params</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">x</span><span class="p">,),</span> <span class="n">kws</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;data&#39;</span><span class="p">:</span><span class="n">data</span><span class="p">})</span>

<span class="k">print</span><span class="p">(</span><span class="n">fit_report</span><span class="p">(</span><span class="n">out</span><span class="p">))</span>


<span class="c1">#&lt;end of examples/doc_withreport.py&gt;</span>
</pre></div>
</div>
<p>which would write out:</p>
<div class="highlight-python"><div class="highlight"><pre>[[Fit Statistics]]
    # function evals   = 85
    # data points      = 1001
    # variables        = 4
    chi-square         = 498.812
    reduced chi-square = 0.500
    Akaike info crit   = -689.223
    Bayesian info crit = -669.587
[[Variables]]
    amp:      13.9121944 +/- 0.141202 (1.01%) (init= 13)
    period:   5.48507044 +/- 0.026664 (0.49%) (init= 2)
    shift:    0.16203676 +/- 0.014056 (8.67%) (init= 0)
    decay:    0.03264538 +/- 0.000380 (1.16%) (init= 0.02)
[[Correlations]] (unreported correlations are &lt;  0.100)
    C(period, shift)             =  0.797
    C(amp, decay)                =  0.582
    C(amp, shift)                = -0.297
    C(amp, period)               = -0.243
    C(shift, decay)              = -0.182
    C(period, decay)             = -0.150
</pre></div>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="model.html" title="Modeling Data and Curve Fitting"
             >next</a> |</li>
        <li class="right" >
          <a href="parameters.html" title="Parameter and Parameters"
             >previous</a> |</li>
   <li>[<a href="intro.html">intro</a>|</li>
   <li><a href="parameters.html">parameters</a>|</li>
   <li><a href="#"> minimize</a>|</li>
   <li><a href="model.html"> model</a>|</li>
   <li><a href="builtin_models.html"> builtin models</a>|</li>
   <li><a href="confidence.html">confidence intervals</a>|</li>
   <li><a href="bounds.html">bounds</a>|</li>
   <li><a href="constraints.html">constraints</a>]</li>
 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &copy; Copyright 2014, Matthew Newville, The University of Chicago,  Till Stensitzki, Freie Universitat Berlin.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.3.5.
    </div>
  </body>
</html>